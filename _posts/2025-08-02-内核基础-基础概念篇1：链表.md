---
layout: post
title: 内核基础-基础概念篇1：链表
date: 2025-07-26 02:44:54 
last_modified_at: 2025-07-26 02:44:54 
tags: [基础篇,模块篇,模块依赖]
author: liushiran
toc: true
description: 本节重点了解内核链表函数的用法
---
# 内核基础‌

## 基础概念篇 1：链表

### ‌**引言**

​	找工作时常刷到链表指针操作的题，曾经思考在如今封装的函数库越来越多越来越便利的情况下，在做什么开发才会用到这些看似基础的链表指针操作呢？答案在Linux内核开发中会经常遇到（至少是常见到）。由于Linux内核没有使用任何C语言库，最初的内核开发者通过手动重新实现并封装了一些基础函数库/函数宏，以供后续开发人员服用，其中就包括链表的基本函数/函数宏。这些基础函数/函数宏在一些书籍中也被称作工具层，而应用这些工具进行开发的内核代码也被称作应用层。了解这些基础函数，是日后做任务调度、内存管理、设备驱动等开发的基础。

​	本章介绍对于链表Linux内核封装了哪些基础函数。使用list_del删除节点后是否需要释放内存？是先删除还是先释放？list_for_each、list_for_each_safe、list_for_each_entry和list_for_each_entry_safe有什么区别？如果不能立即回答出这些基础问题，那么可以通过本章重温。

### **1.**   **链表基本函数**

​	Linux内核采用struct list_head作为通用链表节点，其双向循环结构通过next和prev指针实现闭环管理。这种设计使链表操作与具体数据结构解耦，仅需在业务结构体中嵌入list_head成员即可复用链表功能。例如进程调度模块的task_struct即通过嵌套list_head实现就绪队列。

#### **1.1** **创建和初始化链表**

​	在Linux内核中，链表的创建和初始化可以通过以下两种方式进行：

##### 1. 静态初始化

​	在‌**编译时**完成内存分配，通过宏（如LIST_HEAD(name)）直接定义链表头并初始化，链表头位于全局数据段或栈内存中。

- 特点‌：无需运行时内存申请，链表头内存地址固定且连续。

‌**用法示例：**

```
static LIST_HEAD(my_static_list); // 定义并初始化静态链表头
```



##### ‌2. 动态初始化

​	在‌**运行时**通过函数INIT_LIST_HEAD(&list_head)初始化，链表头需先动态分配内存（如kmalloc）。

- 特点‌：链表头内存位置不固定，需手动管理内存释放。

‌**用法示例**‌：

```
struct list_head *dynamic_list = kmalloc(sizeof(struct list_head), GFP_KERNEL);
INIT_LIST_HEAD(dynamic_list); // 初始化动态分配的链表头
```

在这里，INIT_LIST_HEAD宏将my_dynamic_list的next和prev指针都指向自身，表示初始化一个空链表。注意，在实际的内核代码中，通常不需要显式分配list_head结构体的内存，因为它通常作为其他结构体的成员嵌入其中，并与其他结构体一起分配内存。上面的示例主要是为了说明动态初始化的过程。

#### **1.2** **添加链表节点**

‌**list_add/__list_add：**

- 功能：将一个新元素添加到链表的头部或尾部。
- 指针操作：__list_add函数是list_add的内部实现，它调整新元素以及相邻元素的prev和next指针，确保链表结构的正确性。

**用法示例（__list_add简化版）：**

```
static inline void __list_add(struct list_head *new,
struct list_head *prev,
struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	prev->next = new;
}
```

#### **1.3** **删除链表节点**

**list_del‌：**

- 功能：从链表中删除一个元素。
- 指针操作：list_del函数会调整被删除元素前后元素的prev和next指针，确保链表在删除元素后仍然保持正确结构。

**用法示例**‌：

```
struct my_struct *item = ...;  // 假设这是你要删除的元素
list_del(&item->list);    // 先从链表中删除
kfree(item);       // 然后释放内存
```

**注意：**在调用list_del之后，通常需要对被删除的元素进行kfree操作以释放内存，但具体是先kfree还是先list_del取决于你的代码逻辑。一般来说，你应该先调用list_del将元素从链表中移除，然后再调用kfree释放内存。这是因为如果先释放内存，那么链表中的指针将变成悬空指针，可能导致未定义行为。

#### **1.4** **遍历链表节点**

**list_for_each/list_for_each_safe/list_for_each_entry/list_for_each_entry_safe:**

- 功能：遍历链表中的每个元素。
- 指针操作：通过移动一个临时指针来遍历链表中的每个节点。

##### 1. list_for_each

​	`list_for_each`宏用于遍历一个由`list_head`结构体组成的链表。它直接操作链表节点，不涉及链表节点所嵌入的结构体。

‌**用法示例**‌：

```
struct list_head my_list;
// 假设my_list已经被初始化并填充了数据
struct list_head *pos;
list_for_each(pos, &my_list) {
    // 在这里操作pos指向的list_head节点
}
```

##### 2. list_for_each_safe

​	`list_for_each_safe`是`list_for_each`的一个安全版本，它提供了两个指针来遍历链表。当在遍历链表的同时需要删除节点时，应该使用`list_for_each_safe`，以避免访问无效内存的问题。

‌**用法示例**‌：

```
struct list_head my_list;
// 假设my_list已经被初始化并填充了数据
struct list_head *pos, *tmp;
list_for_each_safe(pos, tmp, &my_list) {
    if (some_condition(pos)) {
        list_del(pos);
        // 执行其他操作，如释放内存等
    }
    // 在这里操作pos指向的list_head节点（如果需要的话）
}
```

​	在这个例子中，`tmp`指针用于在删除`pos`指向的节点后继续安全地遍历链表。

##### 3. list_for_each_entry

​	`list_for_each_entry`宏用于遍历一个由`list_head`结构体嵌入到其他结构体中的链表。它提供了直接访问嵌入`list_head`的结构体的方式。

‌**用法示例**‌：

```
struct my_struct {
    struct list_head list;
    int data;
    // 其他成员...
};
 
LIST_HEAD(my_list);
// 假设my_list已经被初始化并填充了my_struct类型的数据
struct my_struct *pos;
list_for_each_entry(pos, &my_list, list) {
    // 在这里操作pos指向的my_struct结构体
    printk(KERN_INFO "Data: %d\n", pos->data);
}
```

​	在这个例子中，`list_for_each_entry`宏的第三个参数`list`是`my_struct`结构体中嵌入的`list_head`成员的名称。

##### 4. list_for_each_entry_safe

​	`list_for_each_entry_safe`宏是`list_for_each_entry`的一个安全版本。当在遍历链表（链表节点嵌入到其他结构体中）的同时需要删除节点时，应该使用`list_for_each_entry_safe`，以避免访问无效内存的问题。

‌**用法示例**‌：

```
struct my_struct {
    struct list_head list;
    int data;
    // 其他成员...
};
 
LIST_HEAD(my_list);
// 假设my_list已经被初始化并填充了my_struct类型的数据
struct my_struct *pos, *tmp;
list_for_each_entry_safe(pos, tmp, &my_list, list) {
    if (some_condition(pos)) {
        list_del(&pos->list);
        kfree(pos); // 或者其他适当的内存释放操作
    }
    // 在这里操作pos指向的my_struct结构体（如果需要的话）
}
```

​	在这个例子中，`tmp`指针用于在删除`pos`指向的节点后继续安全地遍历链表。

**总结**

- list_for_each：用于遍历纯链表节点。
- list_for_each_safe：list_for_each的安全版本，适用于在遍历过程中需要删除节点的场景。
- list_for_each_entry：用于遍历嵌入list_head的结构体链表，并直接访问这些结构体。
- list_for_each_entry_safe：list_for_each_entry的安全版本，适用于在遍历过程中需要删除节点的场景。

#### **1.5** **其他常用函数**

- ‌list_empty：检查链表是否为空。
- list_is_last：测试是否为链表的最后一个条目。
- list_move/list_move_tail：从一个链表中删除并加入另一个链表的头部或尾部。
- list_splice/list_splice_tail：将两个链表合并。

### **2.**   **用法示例**

#### **2.1** **代码示例**

​	下面给出一个代码示例，展示链表基本函数用法。示例定义一个简单的结构体my_struct，它包含一个整数数据和一个链表头，并展示了如何初始化链表，如何添加、删除和遍历链表元素：

```
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/slab.h>

struct my_struct {
  int data;
  struct list_head list;
};

LIST_HEAD(my_list); // 定义一个链表头

static int __init my_module_init(void)
{
  struct my_struct *item1, *item2;

  // 分配并初始化链表元素
  item1 = kmalloc(sizeof(*item1), GFP_KERNEL);
  if (!item1)
	return -ENOMEM;
  item1->data = 1;
  INIT_LIST_HEAD(&item1->list); // 动态初始化链表元素头

  item2 = kmalloc(sizeof(*item2), GFP_KERNEL);
  if (!item2) {
	kfree(item1);
	return -ENOMEM;
  }
  item2->data = 2;
  INIT_LIST_HEAD(&item2->list); // 动态初始化链表元素头

  // 但实际上，当我们将元素添加到链表中时，不需要单独初始化每个元素的list头，
  // 因为list_add宏会处理这些细节。这里的INIT_LIST_HEAD调用是多余的，
  // 仅用于展示如何初始化list_head结构体。

  // 将元素添加到链表中
  list_add(&item1->list, &my_list);
  list_add(&item2->list, &my_list);

  // 遍历链表并打印元素数据
  struct list_head *pos;
  list_for_each(pos, &my_list) {
	struct my_struct *item = list_entry(pos, struct my_struct, list);
	printk(KERN_INFO "Data: %d\n", item->data);
  }

  // 从链表中删除元素并释放内存
  list_del(&item1->list);
  kfree(item1);

  list_del(&item2->list);
  kfree(item2);

  return 0;
}

static void __exit my_module_exit(void)
{
  // 链表在模块退出时已经被清空，无需额外操作
}

module_init(my_module_init);
module_exit(my_module_exit);
```

#### **2.2** **开发场景示例**

1. **设备驱动**：USB设备链通过`list_head`维护热插拔设备列表。
2. **内存管理**：`vm_area_struct`用链表组织进程地址空间映射。
3. **进程调度**：CFS调度器使用红黑树+链表组合管理运行队列。
