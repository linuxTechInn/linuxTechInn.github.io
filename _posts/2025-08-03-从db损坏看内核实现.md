---
layout: post
title: 我的文章
date: 2025-08-03 22:18:28 
last_modified_at: 2025-08-03 22:18:28 
tags: []
author: wangzijie
toc: true
description: 文章描述

---

# 从db损坏看内核实现

sqlite是一种常用于嵌入式设备的数据库，遵循ACID，嵌入式设备中一些重要数据存在由sqlite生成的数据库文件中，这些文件如果出现了概率性的损坏，往往非常难定位解决，sqlite官方指南中给出了几条建议，先来看其中文件锁相关的一条。



## sqlite File locking problems

https://www.sqlite.org/howtocorrupt.html

```
2. File locking problems
SQLite uses file locks on the database file, and on the write-ahead log or WAL file, to coordinate access between concurrent processes. Without coordination, two threads or processes might try to make incompatible changes to a database file at the same time, resulting in database corruption.


2.2. Posix advisory locks canceled by a separate thread doing close()
The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking. Unfortunately, POSIX advisory locking has design quirks that make it prone to misuse and failure. In particular, any thread in the same process with a file descriptor that is holding a POSIX advisory lock can override that lock using a different file descriptor. One particularly pernicious problem is that the close() system call will cancel all POSIX advisory locks on the same file for all threads and all file descriptors in the process.

So, for example, suppose a multi-thread process has two or more threads with separate SQLite database connections to the same database file. Then a third thread comes along and wants to read something out of that same database file on its own, without using the SQLite library. The third thread does an open(), a read() and then a close(). One would think this would be harmless. But the close() system call caused the locks held on the database by all the other threads to be dropped. Those other threads have no way of knowing that their locks have just been trashed (POSIX does not provide any mechanism to determine this) and so they keep on running under the assumption that their locks are still valid. This can lead to two or more threads or processes trying to write to the database at the same time, resulting in database corruption.

Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.


```

sqlite的write-ahead log或者WAL文件使用的是posix协议锁来保证并发安全，但posix协议锁存在设计缺陷，其中特别提到了，close() 系统调用会取消同一进程中所有线程和所有文件描述符对同一文件持有的所有posix 建议锁。

后文针对这一条提示还举了一个例子：假设一个多线程进程有两个或多个线程，它们分别通过 SQLite 库连接到同一个数据库文件。然后，第三个线程出现，想要自行读取该数据库文件中的内容，而不使用 SQLite 库。该线程执行了 open()、read() 和 close() 操作。人们可能会认为这没什么危害。但 close() 系统调用导致了其他所有线程在该数据库上持有的锁被释放。这些线程无法得知它们的锁刚刚被破坏（POSIX 没有提供任何机制来确定这一点），因此它们继续运行，认为自己的锁仍然有效。这可能导致两个或多个线程或进程同时尝试写入数据库，从而导致数据库损坏。

总结下，就是同一个进程的中的一个线程，不使用sqlite API，而是通过系统调用来直接open，close这个进程中其他线程操作的数据库文件，从而造成锁消亡，引起数据库并发不安全导致数据库文件损坏。

笔者看到这一条提示的时候，也像文档中描述一样，认为有点反直觉，只是读，没有写，直觉上不该造成文件损坏，但查看了内核相关的代码之后确信了这一点。



## pthread_create

先来看linux中创建线程的源代码，glibc中pthread_ctreate的关键代码

```c
static int
create_thread (struct pthread *pd, const struct pthread_attr *attr,
	       bool stopped_start, STACK_VARIABLES_PARMS, bool *thread_ran)
{
  ......
 
  const int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM
			   | CLONE_SIGHAND | CLONE_THREAD
			   | CLONE_SETTLS | CLONE_PARENT_SETTID
			   | CLONE_CHILD_CLEARTID
			   | 0);
 TLS_DEFINE_INIT_TP (tp, pd);
 
  if (__glibc_unlikely (ARCH_CLONE (&start_thread, STACK_VARIABLES_ARGS,
				    clone_flags, pd, &pd->tid, tp, &pd->tid)
			== -1))
  
}
```

使用了clone系统调用，并传递了一系列clone flags，其中和本文提到的问题强相关的CLONE_FILES，CLONE_THREAD。

继续看Linux kernel对clone系统调用的实现

```c
SYSCALL CLONE
--kernel_clone
----copy_process
------dup_task_struct
------copy_files
```

其中copy_process和files强相关的部分

```c
static int copy_files(unsigned long clone_flags, struct task_struct *tsk,
		      int no_files)
{
	struct files_struct *oldf, *newf;

	/*
	 * A background process may not have any files ...
	 */
	oldf = current->files;
	if (!oldf)
		return 0;

	if (no_files) {
		tsk->files = NULL;
		return 0;
	}

	if (clone_flags & CLONE_FILES) {
		atomic_inc(&oldf->count);
		return 0;
	}
	//...
}

```

也就是说，在copy_files过程中，因为使用了CLONE_FILES flag，并没有给这个新创建的线程dup一份files，而只是给current的files增加了count计数。

而在更早调用的dup_task_struct中：

```c
static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
{
	struct task_struct *tsk;
	int err;

	if (node == NUMA_NO_NODE)
		node = tsk_fork_get_node(orig);
	tsk = alloc_task_struct_node(node);
	if (!tsk)
		return NULL;

	err = arch_dup_task_struct(tsk, orig);
	if (err)
		goto free_tsk;
//.....
}

```

alloc_task_struct_node完成了task_struct内存的分配

```c
static inline struct task_struct *alloc_task_struct_node(int node)
{
	return kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);
}
```

alloc_task_struct_node中进行了所谓的“浅拷贝”

```c
int __weak arch_dup_task_struct(struct task_struct *dst,
					       struct task_struct *src)
{
	*dst = *src;
	return 0;
}
```

当这些操作完成之后，新创建的线程虽然拥有了自己的task_struct,但没有自己的files，而是和父进程共享一份files。



## close

sqlite指南中描述的线程调用close，如何影响文件锁？

```c
SYSCALL close
--file_close_fd
//此步骤中的current->files已经是共享的父进程的files
--filp_flush(file, current->files);
----locks_remove_posix
```

再看locks_remove_posix如何处理

```c
void locks_remove_posix(struct file *filp, fl_owner_t owner)
{
	int error;
	struct inode *inode = file_inode(filp);
	struct file_lock lock;
	struct file_lock_context *ctx;

	//从该步骤就能看出，文件锁上下文记录在inode中
  //同时该函数传入的owner是current->files
  //从此处可以理解为：确定一个文件锁的二元组<files,inode>
	ctx = locks_inode_context(inode);
	if (!ctx || list_empty(&ctx->flc_posix))
		return;

  
  //remove_posix顾名思义，要对file全范围加"UNLOCK"锁
	locks_init_lock(&lock);
	lock.c.flc_type = F_UNLCK;
	lock.c.flc_flags = FL_POSIX | FL_CLOSE;
	lock.fl_start = 0;
	lock.fl_end = OFFSET_MAX;
	lock.c.flc_owner = owner;
	lock.c.flc_pid = current->tgid;
	lock.c.flc_file = filp;
	lock.fl_ops = NULL;
	lock.fl_lmops = NULL;

	error = vfs_lock_file(filp, F_SETLK, &lock, NULL);

	if (lock.fl_ops && lock.fl_ops->fl_release_private)
		lock.fl_ops->fl_release_private(&lock);
//....
}
```

再看vfs_lock_file ->posix_lock_file ->posix_lock_inode如何处理

```c
posix_lock_inode关键代码片段


/* Process locks with this owner. */
	list_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, c.flc_list) {
		if (!posix_same_owner(&request->c, &fl->c))
			break;

			/* Processing for different lock types is a bit
			 * more complex.
			 */
			if (fl->fl_end < request->fl_start)
				continue;
			if (fl->fl_start > request->fl_end)
				break;
			if (lock_is_unlock(request))
				added = true;
			if (fl->fl_start < request->fl_start)
				left = fl;
			/* If the next lock in the list has a higher end
			 * address than the new one, insert the new one here.
			 */
			if (fl->fl_end > request->fl_end) {
				right = fl;
				break;
			}
			if (fl->fl_start >= request->fl_start) {
				/* The new lock completely replaces an old
				 * one (This may happen several times).
				 */
				if (added) {
					locks_delete_lock_ctx(&fl->c, &dispose);
					continue;
				}
				/*
				 * Replace the old lock with new_fl, and
				 * remove the old one. It's safe to do the
				 * insert here since we know that we won't be
				 * using new_fl later, and that the lock is
				 * just replacing an existing lock.
				 */
				error = -ENOLCK;
				if (!new_fl)
					goto out;
				locks_copy_lock(new_fl, request);
				locks_move_blocks(new_fl, request);
				request = new_fl;
				new_fl = NULL;
				locks_insert_lock_ctx(&request->c,
						      &fl->c.flc_list);
				locks_delete_lock_ctx(&fl->c, &dispose);
				added = true;
			}
		}
	}
```

从此处可以看出，locks_remove_posix，当传入UNLOCK的类型锁时，会遍历相同files的所有锁，并将其移出，也就是说，子线程只需要一次open，一次close，就可以把该共享父进程的files中所有文件的posix协议锁全部移除掉。



## 总结

当发生以下sqlite指南描述的以下场景，比如Process A下的thread a,b,c分别操作同一个文件

a										b									c

Open							Open                             Open

Flock  write lock												

​																			close

写数据																

​									Flock  write lock

​									写数据

close							close



只看a，b，本来b所写的数据按照加锁的时序一定在a之后，但c的open，close完全移除了a加的锁，导致b写数据和a同时并发，这样当业务需要a，b的并发安全，是很有可能造成文件损坏的。

所以，想要用好posix协议锁，需要对内核有了解。